# üöÄ Radar Motu: Sistema de Localiza√ß√£o Veicular Indoor de Alta Precis√£o

### *Sua frota sob controle, seu p√°tio na palma da m√£o.*


## üë®‚Äçüíªüë©‚Äçüíªüë©‚Äçüíª Equipe de Desenvolvimento**

| Nome                  | RM     | Turma   |                                                                                      
| Paulo Andr√© Carminati | 557881 | 2-TDSPZ | 
| Arthur Bispo de Lima  | 557568 | 2-TDSPV | 
| Jo√£o Paulo Moreira    | 557808 | 2-TDSPV |

---

![Arquitetura da Solu√ß√£o Radar Motu](./assets/Image/arquitetura-solucao.png)
*Diagrama da arquitetura da solu√ß√£o, demonstrando o fluxo de dados do dispositivo IoT (TAG BLE) at√© a interface do operador.*

---

## üìã Tabela de Conte√∫dos (Ser√° preenchida ao final)

---

## 1. Vis√£o Geral do Projeto

O **Radar Motu** √© uma solu√ß√£o completa e robusta de IoT (Internet of Things) desenvolvida para resolver um problema cr√≠tico em p√°tios de ve√≠culos: a localiza√ß√£o r√°pida e precisa de motocicletas. O sistema eleva a opera√ß√£o de p√°tio de um processo manual e demorado para uma solu√ß√£o digital, eficiente e confi√°vel.

Para alcan√ßar este objetivo, desenvolvemos um ecossistema completo que inclui:
* **Hardware de Baixo Custo:** Utilizando microcontroladores ESP32 como √¢ncoras e como dispositivo rastre√°vel (TAG).
* **APIs Especializadas:** Duas APIs criadas por n√≥s:
    1.  Uma **API de Reconhecimento de Placas (OCR)** que digitaliza e identifica os ve√≠culos.
    2.  Uma **API de Triangula√ß√£o** que processa os dados dos sensores para calcular a localiza√ß√£o em tempo real.
* **Aplica√ß√£o M√≥vel Intuitiva:** Um app que centraliza as opera√ß√µes, permitindo ao operador escanear uma placa, visualizar a localiza√ß√£o exata da moto em um mapa digital e usar um radar de proximidade para a localiza√ß√£o final.

Este projeto representa uma solu√ß√£o de ponta a ponta, desde a captura de dados no ambiente f√≠sico at√© a sua apresenta√ß√£o inteligente na interface do operador.

## 2. Arquitetura da Solu√ß√£o IoT

O projeto foi constru√≠do sobre um ecossistema IoT coeso e de ponta a ponta. A arquitetura foi dividida em camadas, demonstrando o fluxo claro dos dados, desde o ambiente f√≠sico at√© a interface do usu√°rio.

### Camada F√≠sica (Hardware - O P√°tio Conectado)

* **Dispositivo M√≥vel (A Moto/TAG):**
    * Para o MVP, utilizamos um **ESP32 DEVKIT V1** como dispositivo rastre√°vel, simulando a TAG que seria acoplada √† moto.
    * Ele √© programado via **IDE do Arduino** para atuar como um beacon Bluetooth Low Energy (BLE), transmitindo continuamente sua identidade.
    * A alimenta√ß√£o √© feita por um **Power Bank**, com o plano de evoluir para uma solu√ß√£o com baterias recarreg√°veis em uma vers√£o futura.

* **√Çncoras (Gateways de Dados):**
    * A infraestrutura do p√°tio √© composta por **4 √Çncoras**, cada uma sendo um **ESP32 DEVKIT V1**.
    * Sua fun√ß√£o √© atuar como *gateways*: elas escaneiam o ambiente, capturam os sinais BLE emitidos pela TAG e medem a intensidade do sinal recebido (**RSSI**).
    * Cada √¢ncora √© equipada com um **Buzzer** para testes de comandos remotos e alimentada por um **Power Bank**, garantindo flexibilidade na instala√ß√£o.

### Camada de Processamento (Backend - O C√©rebro da Opera√ß√£o)

* **`radarmotu-api` (FastAPI/Python):** O backend √© onde a intelig√™ncia da solu√ß√£o reside. Ele √© respons√°vel por:
    1.  **Ingest√£o de Dados:** Receber os valores de RSSI enviados pelas 4 √¢ncoras via Wi-Fi.
    2.  **C√°lculo de Triangula√ß√£o:** Utilizar nossa **API de triangula√ß√£o customizada** para processar os m√∫ltiplos valores de RSSI. O algoritmo calcula a posi√ß√£o (coordenadas X, Y) do dispositivo m√≥vel no p√°tio com alta precis√£o.
    3.  **L√≥gica de Neg√≥cio:** Gerenciar a **API de reconhecimento de placas (OCR)**, associar ve√≠culos a TAGs e persistir todos os dados no banco de dados (`radarmotu.db`).

> **Ponto-chave:** O c√°lculo complexo de triangula√ß√£o √© centralizado no backend. Isso torna o hardware de ponta (√¢ncoras) mais simples e de baixo custo, enquanto aproveita o poder de processamento do servidor.

### Camada de Apresenta√ß√£o (Frontend - A Interface do Operador)

* **`radarmotu-app` (React Native):** O aplicativo m√≥vel √© a interface homem-m√°quina (IHM) da nossa solu√ß√£o.
    * Ele **consome os dados j√° processados** pelo backend. Ao inv√©s de receber dados brutos de RSSI, ele solicita √† API a posi√ß√£o final da moto.
    * Sua principal fun√ß√£o √© **visualizar os dados**: exibir a localiza√ß√£o no "Mapa do P√°tio" e a proximidade no "Radar", garantindo uma experi√™ncia de usu√°rio fluida e intuitiva.

## 3. Atendendo aos Crit√©rios da 3¬™ Sprint

O projeto foi meticulosamente planejado e executado para satisfazer e exceder todos os crit√©rios de avalia√ß√£o propostos para esta Sprint.

### ‚úÖ Comunica√ß√£o entre Sensores/Vis√£o e Backend | `(at√© 30 pts)`

A comunica√ß√£o √© o cora√ß√£o da nossa solu√ß√£o IoT e foi implementada com sucesso, garantindo um fluxo de dados robusto e em tempo real.

1.  **Comunica√ß√£o Sensores ‚ûî Backend (IoT):**
    * As 4 √¢ncoras ESP32 capturam os dados brutos de RSSI da TAG m√≥vel.
    * Esses dados s√£o enviados via Wi-Fi (HTTP) para endpoints espec√≠ficos da nossa **`radarmotu-api`**. O payload enviado √© estruturado, contendo `ID_DA_ANCORA`, `ID_DA_TAG` e `VALOR_RSSI`.
    * Este fluxo de "telemetria" √© a base para o sistema de localiza√ß√£o.

2.  **Comunica√ß√£o Vis√£o ‚ûî Backend (OCR):**
    * O aplicativo utiliza nossa **API de reconhecimento de placas customizada**.
    * A placa, uma vez digitalizada e convertida para string, √© enviada para um endpoint no backend (ex: `/vehicles/find-by-plate`).
    * O backend valida a placa no banco de dados e retorna a TAG associada, integrando o mundo f√≠sico (placa) ao nosso ecossistema digital (TAG).

### ‚úÖ Dashboard/Output Visual com Dados em Tempo Real | `(at√© 30 pts)`

O `radarmotu-app` funciona como um dashboard operacional completo, fornecendo ao usu√°rio final um output visual claro e din√¢mico dos dados processados pelo backend.

* **Dashboard Principal (Mapa do P√°tio):** Esta tela exibe a posi√ß√£o calculada da moto (ponto verde) sobre uma planta do p√°tio. A interface consome os dados de coordenadas (X, Y) da API e atualiza a posi√ß√£o em tempo real, oferecendo uma vis√£o macro da localiza√ß√£o do ativo.
* **Output de Alta Precis√£o (Radar de Proximidade):** Para a busca final, o radar exibe a **Dist√¢ncia** e o **RSSI** em tempo real. Esses valores mudam dinamicamente conforme o operador se aproxima do ve√≠culo, servindo como um output visual e num√©rico preciso para a localiza√ß√£o final.

| Mapa do P√°tio (Dashboard) | Radar de Proximidade (Output Real-Time) |
| :---: | :---: |
| ![Mapa do P√°tio](https://i.imgur.com/Bf0s07t.jpeg) | ![Radar de Proximidade](https://i.imgur.com/b97j0hD.jpeg) |


### ‚úÖ Persist√™ncia e Estrutura√ß√£o dos Dados | `(at√© 20 pts)`

Garantimos a integridade e a organiza√ß√£o dos dados atrav√©s de uma arquitetura de backend bem definida.

* **Persist√™ncia:** Utilizamos um banco de dados **SQLite** (`radarmotu.db`), que √© leve, serverless e ideal para o escopo do nosso MVP. Ele armazena todas as informa√ß√µes essenciais da aplica√ß√£o.
* **Estrutura:** Seguimos as melhores pr√°ticas do FastAPI, utilizando:
    * **`models.py`:** Define a estrutura das tabelas do banco de dados (via SQLAlchemy ORM).
    * **`schemas.py`:** Define os schemas de dados para valida√ß√£o na API (via Pydantic), garantindo que apenas dados v√°lidos e bem-formados sejam aceitos e retornados.
    * **`anchors.json`:** Um arquivo de configura√ß√£o para persistir as posi√ß√µes fixas das √¢ncoras no p√°tio.

### ‚úÖ Organiza√ß√£o do C√≥digo e Documenta√ß√£o T√©cnica | `(at√© 20 pts)`

A base de c√≥digo do projeto foi organizada com um claro princ√≠pio de **separa√ß√£o de responsabilidades**, facilitando a manuten√ß√£o e a escalabilidade.

* **Backend (`radarmotu-api`):**
    * `main.py`: Ponto de entrada da aplica√ß√£o.
    * `routers/`: Define os endpoints da API (ex: `/vehicles`, `/location`), separando a l√≥gica de roteamento.
    * `services/` e `estimator.py`: Cont√™m a l√≥gica de neg√≥cio principal, incluindo o algoritmo de triangula√ß√£o.
    * `database.py`: Gerencia a conex√£o e a sess√£o com o banco de dados.

* **Frontend (`radarmotu-app`):**
    * `screens/`: Cada arquivo (`.tsx`) representa uma tela do aplicativo (ex: `MapaScreen`, `RadarProximidadeScreen`).
    * `components/`: Armazena componentes reutiliz√°veis da interface (ex: `VehicleCard`).
    * `services/`: Centraliza a l√≥gica de comunica√ß√£o com a nossa API.

* **Documenta√ß√£o:** Este arquivo `README.md` serve como a documenta√ß√£o t√©cnica central do projeto.

## 4. Demonstra√ß√£o em V√≠deo

Para uma vis√£o completa da solu√ß√£o em funcionamento, desde o escaneamento da placa at√© a localiza√ß√£o em tempo real com o radar, assista √† nossa apresenta√ß√£o e demonstra√ß√£o no YouTube.

> ### üé• **[ASSISTIR AO V√çDEO DE DEMONSTRA√á√ÉO NO YOUTUBE]**
> *https://www.youtube.com/watch?v=MCH5RcNdic0*

---

## 5. Tecnologias Utilizadas

Este projeto foi constru√≠do com uma combina√ß√£o de tecnologias modernas e eficientes, escolhidas para garantir desempenho, escalabilidade e uma √≥tima experi√™ncia de desenvolvimento.

| Categoria | Tecnologias |
| :--- | :--- |
| **Backend** | ![Python](https://img.shields.io/badge/Python-3776AB?style=for-the-badge&logo=python&logoColor=white) ![FastAPI](https://img.shields.io/badge/FastAPI-005571?style=for-the-badge&logo=fastapi&logoColor=white) ![SQLAlchemy](https://img.shields.io/badge/SQLAlchemy-D71F00?style=for-the-badge&logo=sqlalchemy&logoColor=white) |
| **Frontend (Mobile)** | ![React Native](https://img.shields.io/badge/React_Native-20232A?style=for-the-badge&logo=react&logoColor=61DAFB) ![Expo](https.img.shields.io/badge/Expo-000020?style=for-the-badge&logo=expo&logoColor=white) ![TypeScript](https://img.shields.io/badge/TypeScript-3178C6?style=for-the-badge&logo=typescript&logoColor=white) |
| **Hardware (IoT)** | ![ESP32](https://img.shields.io/badge/ESP32-E7332A?style=for-the-badge&logo=espressif&logoColor=white) ![Arduino IDE](https://img.shields.io/badge/Arduino_IDE-00979D?style=for-the-badge&logo=arduino&logoColor=white) ![Bluetooth](https://img.shields.io/badge/Bluetooth_BLE-0082FC?style=for-the-badge&logo=bluetooth&logoColor=white) |
| **Ferramentas & DevOps** | ![VSCode](https://img.shields.io/badge/VSCode-007ACC?style=for-the-badge&logo=visual-studio-code&logoColor=white) ![Git](https://img.shields.io/badge/Git-F05032?style=for-the-badge&logo=git&logoColor=white) ![GitHub](https://img.shields.io/badge/GitHub-181717?style=for-the-badge&logo=github&logoColor=white) |

## 6. Estrutura do Projeto

O c√≥digo-fonte foi organizado em um formato de monorepo, separando de forma clara e l√≥gica as tr√™s principais frentes do projeto: `hardware`, `radarmotu-api` (backend) e `radarmotu-app` (frontend). Essa abordagem facilita o desenvolvimento, a manuten√ß√£o e a escalabilidade da solu√ß√£o.

## 6. Estrutura do Projeto

O c√≥digo-fonte foi organizado em um formato de monorepo, separando de forma clara e l√≥gica as tr√™s principais frentes do projeto: `hardware`, `radarmotu-api` (backend) e `radarmotu-app` (frontend). Essa abordagem facilita o desenvolvimento, a manuten√ß√£o e a escalabilidade da solu√ß√£o.

### üìÅ `radarmotu-api` (Backend)

A API segue uma arquitetura robusta e modular, inspirada nas melhores pr√°ticas de desenvolvimento com FastAPI.

```t
radarmotu-api/
‚îî‚îÄ‚îÄ app/
    ‚îú‚îÄ‚îÄ routers/        # Define os endpoints da API (as "rotas")
    ‚îú‚îÄ‚îÄ services/       # Cont√©m a l√≥gica de neg√≥cio principal
    ‚îú‚îÄ‚îÄ .env.example    # Exemplo de vari√°veis de ambiente
    ‚îú‚îÄ‚îÄ anchors.json    # Configura√ß√£o das posi√ß√µes das √¢ncoras
    ‚îú‚îÄ‚îÄ database.py     # Gerencia a conex√£o com o banco de dados
    ‚îú‚îÄ‚îÄ estimator.py    # M√≥dulo com o algoritmo de triangula√ß√£o/localiza√ß√£o
    ‚îú‚îÄ‚îÄ main.py         # Ponto de entrada principal da aplica√ß√£o FastAPI
    ‚îú‚îÄ‚îÄ models.py       # Define as tabelas do banco de dados (SQLAlchemy)
    ‚îú‚îÄ‚îÄ schemas.py      # Define os schemas de dados para valida√ß√£o (Pydantic)
    ‚îú‚îÄ‚îÄ security.py     # L√≥gica de autentica√ß√£o e seguran√ßa
    ‚îî‚îÄ‚îÄ radarmotu.db    # Arquivo do banco de dados SQLite
```

main.py: Inicializa a aplica√ß√£o e inclui os roteadores.

routers/: Cada arquivo aqui define um grupo de endpoints (ex: /vehicles, /tags), mantendo o c√≥digo de roteamento organizado.

services/ e estimator.py: O cora√ß√£o da API. services orquestra as regras de neg√≥cio, enquanto estimator.py cont√©m a l√≥gica matem√°tica para calcular a posi√ß√£o do ve√≠culo com base no RSSI.

models.py e schemas.py: Trabalham juntos para garantir que os dados que entram e saem da API e do banco de dados sejam sempre bem estruturados e validados.

üìÅ radarmotu-app (Frontend)
O aplicativo m√≥vel foi estruturado de forma a separar a l√≥gica da interface, facilitando a reutiliza√ß√£o de componentes e a manuten√ß√£o das telas.

```t
radarmotu-app/
‚îú‚îÄ‚îÄ assets/             # Imagens, fontes e outros arquivos est√°ticos
‚îú‚îÄ‚îÄ components/         # Componentes de UI reutiliz√°veis (ex: bot√µes, cards)
‚îÇ   ‚îî‚îÄ‚îÄ VehicleCard.tsx
‚îú‚îÄ‚îÄ config/             # Arquivos de configura√ß√£o
‚îÇ   ‚îî‚îÄ‚îÄ env.ts
‚îú‚îÄ‚îÄ screens/            # Cada arquivo √© uma tela do aplicativo
‚îÇ   ‚îú‚îÄ‚îÄ HomeScreen.tsx
‚îÇ   ‚îú‚îÄ‚îÄ MapaScreen.tsx
‚îÇ   ‚îî‚îÄ‚îÄ RadarProximidadeScreen.tsx
‚îú‚îÄ‚îÄ services/           # L√≥gica de comunica√ß√£o com a API backend
‚îú‚îÄ‚îÄ App.tsx             # Componente raiz do aplicativo
‚îî‚îÄ‚îÄ package.json        # Depend√™ncias e scripts do projeto
```

screens/: Cont√©m a estrutura principal de cada tela vis√≠vel para o usu√°rio. A l√≥gica de cada tela √© encapsulada aqui.

components/: Pe√ßas fundamentais da nossa interface. Ao criar componentes como VehicleCard.tsx, evitamos a repeti√ß√£o de c√≥digo e mantemos um design consistente.

services/: Esta pasta abstrai toda a complexidade da comunica√ß√£o HTTP. As telas chamam fun√ß√µes simples daqui (ex: getVehicleLocation(plate)) sem precisar saber os detalhes da API.

config/: Centraliza configura√ß√µes importantes, como o endere√ßo da nossa API, facilitando a troca entre ambientes de desenvolvimento e produ√ß√£o.

## 7. Como Rodar o Projeto do Zero

Siga os passos abaixo para configurar e executar o ambiente de desenvolvimento completo em sua m√°quina local.

### Pr√©-requisitos
* **Node.js (LTS)** e **npm**
* **Python 3.9+** e **pip**
* **Git**
* **Android Studio** com um Emulador Android configurado (ou um dispositivo f√≠sico)
* **Expo Go App** instalado no seu dispositivo f√≠sico (caso opte por n√£o usar o emulador)

---
### Passo 1: Clonar o Reposit√≥rio
```bash
git clone [URL_DO_SEU_REPOSITORIO]
cd [NOME_DA_PASTA_DO_PROJETO]

### Passo 2: Configurar e Rodar o Backend (API)

# Navegue at√© a pasta da API
cd radarmotu-api

# Crie e ative um ambiente virtual
python -m venv venv
# No Windows:
.\venv\Scripts\activate
# No Linux/Mac:
# source venv/bin/activate

# Instale as depend√™ncias do Python
pip install -r requirements.txt

# Inicie o servidor de desenvolvimento
uvicorn app.main:app --reload --host 0.0.0.0 --port 8000

‚úÖ Pronto! A API estar√° rodando e acess√≠vel na sua rede local. Anote o seu endere√ßo de IP (ex: 192.168.1.10), voc√™ precisar√° dele no App.

### Passo 3: Configurar e Rodar o Frontend (App)

# Em um novo terminal, navegue at√© a pasta do App
cd radarmotu-app

# Instale as depend√™ncias do Node.js
npm install

# (Opcional) Se encontrar erros de depend√™ncia, use:
npm install --legacy-peer-deps

# Inicie o servidor do Expo
npx expo start

‚ùó Importante: Ap√≥s iniciar o Expo, abra o arquivo radarmotu-app/config/env.ts (ou similar) e atualize o endere√ßo da API para o IP da m√°quina onde o backend est√° rodando (ex: http://192.168.1.10:8000).


Ap√≥s configurar o IP, voc√™ pode:

Escanear o QR Code com o app Expo Go no seu celular.

Ou, para rodar diretamente no emulador/dispositivo USB:

npx expo run:android
